//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Net;
using CC.Runtime.Utils;
using System.IO;
using System.Collections;
using System.Net.Sockets;
using UnityEngine;
using CC.Runtime.signals;
using CC.Runtime.PB;
using CC.Runtime;
using LuaInterface;
using ProtoBuf;
using Games;

namespace CC.Runtime
{
    public enum SocketStatus
    {
        None,
        Ready,
        Ok,
        ReReady,
        Errored,
        Reconn,
        Reconning
    }
    
    public class CommonSocketServer : ISocketServer
    {
        public CommonSocketServer(SocketManager sm, SocketId si){
            this.sm = sm;
            this.sid = si;
            readpool = SimplePool<ReadData>.Instance;
            frametemp = new List<ReadData>();
            outbuffer = new byte[65535];
        }
        public string URL{get;set;}
        public int Port{get;set;}
		public float ReconnSpan{get;set;}

        private SocketManager sm ;
        private SocketId sid;
        private IPEndPoint endp;
        private Socket socket;
        private SocketStatus status = SocketStatus.None;
        private ReadData rdata;
        private byte[] outbuffer;
        private float reconnect;
        private float reconnwait;
		
		private Coroutine reconnectCoroutiner;

		public HSignal<SocketId> sConnect = new HSignal<SocketId>();
		public HSignal<SocketId> sReconnect = new HSignal<SocketId>();
		public HSignal<SocketId> sDisconnect = new HSignal<SocketId>();

        private float lastSendTime = -1;

        public IEnumerable<ReadData> OnFrame()
        {
            if (status == SocketStatus.Ok)
            {
                frametemp.Clear();
				if (!socket.Connected || (lastSendTime > 0 && Time.time - lastSendTime >= GameConst.NetWorkTimeOut))
                {
//                    root.DispatchSignal<DisconnectSignal,SocketId>(sid);
                    Reconnect();
                }
                else
                {
                    ReadData();
                }
            }
            else if (status == SocketStatus.Reconning)
            {
                ReadData();
            }
            return frametemp;
        }

        private void ReadData()
        {
            try
            {
                int avail = socket.Available;
                while (avail > 0)
                {
                    lastSendTime = -1;
                    
                    // Debug.Log("Receiveable" + avail + " bytes from server");
                    int byt = socket.Receive(rdata.buffer, rdata.read, rdata.total - rdata.read, SocketFlags.None);
                    avail -= byt;
                    rdata.read += byt;
                    if (rdata.read == rdata.total)
                    {
                        if (rdata.state == ReadState.Header)
                        {
                            int len = BitConverter.ToInt32(rdata.buffer, 0);
                            int checkcode = BitConverter.ToInt32(rdata.buffer, 4);
                            int msgid = BitConverter.ToInt16(rdata.buffer, 8);
                            int retcode = BitConverter.ToInt16(rdata.buffer, 10);
                            //int roleId = BitConverter.ToInt32(rdata.buffer, 12);
                            //Debug.Log("len=" + len + ", checkcode=" + checkcode + ", msgid=" + msgid + ", retcode=" + retcode );
                            
                            rdata.proto = msgid;
                            rdata.retcode = retcode;
                            rdata.read = 0;
                            rdata.total = len - 12;  // minus 16 bytes head length
                            rdata.state = ReadState.Content;
                            
                            if (rdata.total == 0)
                            {
                                rdata.stream.SetLength(0);
                                frametemp.Add(rdata);
                                rdata = readpool.Get();
                                rdata.socket = socket;
                            }
                            //print("id  " + id.ToString() + "len  " + l.ToString());
                        }
                        else
                        {
                            rdata.stream.Seek(0, SeekOrigin.Begin);
                            rdata.stream.Write(rdata.buffer, 0, rdata.total);
                            frametemp.Add(rdata);
                            rdata = readpool.Get();
                            rdata.socket = socket;
                        }
                    }
                }
                
            }
            catch (Exception ex)
            {
                //Debug.Log("================================exp====");
                HDebugger.LogException(HDebuggerModule.Proto, ex);
                Reconnect();
            }
        }
        
        public void Start()
        {
            IPAddress[] addrs = Dns.GetHostAddresses(URL);
            if (addrs.Length > 0)
            {
                endp = new IPEndPoint(addrs[0], Port);
                #if UNITY_WEBPLAYER
                if( !Security.PrefetchSocketPolicy(addrs[0].ToString(),Port,3000) ){
                    Debugger.LogError("Get Socket Polily Failed");
                    return;
                }
                #endif
                socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                sm.StartCoroutine(ConnectFrame(socket, endp));
            }

            lastProto = new Pair<int, Stream>();
            lastProto.first = -1;
            Coo.packetManager.AddCallback<S_ReConnect_0x101>(S_ReConnect_0x101);
        }
        public void SendProtoMessage(int id, Stream stream)
        {
            if (status == SocketStatus.Ok)
            {
                SendProtoMessageImpl(id, stream);
				if (lastSendTime < 0)
                	lastSendTime = Time.time;

                if (lastProto != null && id != Coo.packetManager.reconnectMessage)
                {
                    if (lastProto.first > 0)
                    {
                        lastProto.second.Dispose();
                    }
                    lastProto.first = id;
                    lastProto.second = stream;
                }
                else
                {
                    stream.Dispose();
                }
            }
        }

        public void SendEmptyMessage(int id)
        {
            if (status == SocketStatus.Ok)
            {
                SendEmptyMessageImpl(id);
            }
        }

        protected bool Send(byte[] buffer, int offset, int size)
        {
            if (socket.Connected)
            {
                SocketError sr;
                int i = socket.Send(buffer, offset, size, SocketFlags.None, out sr);
                
                if (i == -1 || sr != SocketError.Success)
                {
                    HDebugger.Log(HDebuggerModule.Proto, sr.ToString());
                    Reconnect();
                    return false;
                }
                return true;
            }
            return false;
        }

        protected bool SendProtoMessageImpl(int msgid, Stream stream)
        {
            if (stream == null)
            {
                return SendEmptyMessageImpl(msgid);
            }

            Debug.Log("SendProtoMesageImple. messge id=0x" + Convert.ToString(msgid, 16));
            stream.Seek(0, SeekOrigin.Begin);

            int len = 4/*协议长度 int*/ + 4/*校验码int*/ + 2/*协议号short*/ + 2/*返回码short*/ + (int)stream.Length;
            BitConverter.GetBytes(len).CopyTo(outbuffer, 0);
            BitConverter.GetBytes(0xA1618B).CopyTo(outbuffer, 4);
            BitConverter.GetBytes((UInt16)msgid).CopyTo(outbuffer, 8);
            BitConverter.GetBytes((UInt16)0).CopyTo(outbuffer, 10);
            //BitConverter.GetBytes((UInt16)0).CopyTo(outbuffer, 12);
            stream.Read(outbuffer, 12, (int)stream.Length);

            return Send(outbuffer, 0, len);
        }
        
        protected bool SendEmptyMessageImpl(int msgid)
        {
            int len = 4/*协议长度 int*/ + 4/*校验码int*/ + 2/*协议号short*/ + 2/*返回码short*/;
            BitConverter.GetBytes(len).CopyTo(outbuffer, 0);
            BitConverter.GetBytes(0xA1618B).CopyTo(outbuffer, 4);
            BitConverter.GetBytes((UInt16)msgid).CopyTo(outbuffer, 8);
            BitConverter.GetBytes((UInt16)0).CopyTo(outbuffer, 10);
            //BitConverter.GetBytes((UInt16)0).CopyTo(outbuffer, 12);

            return Send(outbuffer, 0, len);
        }

        public IEnumerator ConnectFrame(Socket sock, IPEndPoint ep)
        {
            bool conn = false;
            while (!conn)
            {
                try
				{
					Debug.Log(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffff") + " ConnectFrame sock.Connect(ep) pre ReconnSpan=" + ReconnSpan);
					sock.Connect(ep);
                    conn = true;
					Debug.Log(DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffff") + " ConnectFrame conn=" + conn);
                    break;
                }
                catch (Exception ex)
                {
					Debug.Log(ex);
                    HDebugger.LogException(HDebuggerModule.Proto, ex);
                    conn = false;
                }
                
                yield return new WaitForSeconds(ReconnSpan);
            }
            status = SocketStatus.Ok;
            rdata = readpool.Get();
            rdata.socket = sock;
			Debug.Log("CommonSocketServer connect status=" + status);
			sConnect.Dispatch(sid);
        }

        public IEnumerator ReconnectFrame(Socket sock)
        {
            bool conn = false;
            yield return 0 ;
            while (!conn)
            {
                try
                {
                    sock.Connect(endp);
                    conn = true;
                    break;
                }
                catch (Exception)
                {
                }
                yield return new WaitForSeconds(ReconnSpan);
            }
            status = SocketStatus.Reconning;

            C_ReConnect_0x101 msg = new C_ReConnect_0x101();
            LuaTable user = LuaScriptMgr.Instance.GetLuaTable("User");
            msg.session_id = user.rawget("session_id") as string;

            Stream str = new MemoryStream();
            Serializer.Serialize<C_ReConnect_0x101>(str, msg);
            SendProtoMessageImpl(Coo.packetManager.reconnectMessage, str);

            Debug.Log("network log : send reconnect proto to service...");
        }

        private void S_ReConnect_0x101(S_ReConnect_0x101 msg)
        {
            status = SocketStatus.Ok;
            Debug.Log("network log : reconnect finish, sid = " + sid);

            sReconnect.Dispatch(sid);

			if (lastProto != null && lastProto.first > 0)
            {
				if (msg.retcode == 0)
                	SendProtoMessageImpl(lastProto.first, lastProto.second);
				
                lastProto.first = -1;
                lastProto.second.Dispose();
            }
        }

        public void Reconnect()
        {
            if( status != SocketStatus.Errored ){
				sDisconnect.Dispatch(sid);
                status = SocketStatus.Errored;
                rdata.Reset();
                socket.Close();
                socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
				reconnectCoroutiner = sm.StartCoroutine(ReconnectFrame(socket));
            }
        }

		public void Stop()
		{
			status = SocketStatus.None;
			if(socket != null)
			{
				socket.Close();
			}

			if(rdata != null) rdata.Reset();

			if(frametemp != null) frametemp.Clear();

            lastProto.first = -1;
            Coo.packetManager.RemoveCallback<S_ReConnect_0x101>(S_ReConnect_0x101);
        }
        
        private SimplePool<ReadData> readpool;
        private Pair<int, Stream> lastProto;
        private List<ReadData> frametemp;

    }
}